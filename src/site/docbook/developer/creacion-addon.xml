<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="creacion-addon" xml:lang="es"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Creación de proyecto de add-on</title>

  <para xml:lang="es">Estos son los a seguir para prepara un proyecto de
  add-on:</para>

  <orderedlist>
    <listitem>
      <para>Crear el directorio que contendrá el proyecto del add-on.</para>
    </listitem>

    <listitem>
      <para>Ejecutar la consola del framework desde el directorio que acabamos
      de crear.</para>
    </listitem>

    <listitem>
      <para>Crear el proyecto con el comando <command>project</command> usando
      el <emphasis>template</emphasis> de add-on. Ejemplo:</para>

      <programlisting>project --topLevelPackage org.gvnix.cxf.roo.addon --template ROO_ADDON_SIMPLE</programlisting>

      <para>El nombre del paquete base tiene las siguientes
      limitaciones:</para>

      <itemizedlist>
        <listitem>
          <para>Debe empezar por <package>org.</package>,
          <package>net.</package> o <package>com.</package>.</para>
        </listitem>

        <listitem>
          <para>Debe terminar en <package>roo.addon</package>.</para>
        </listitem>
      </itemizedlist>
    </listitem>

    <listitem>
      <para>utilizar el formato de paquetes subsiguientes con la misma
      estructura que tengan las librerías que estamos extendiendo y/o
      utilizando como base. Ejemplos:</para>

      <itemizedlist>
        <listitem>
          <para><package>org.gvnix.cxf.roo.addon</package></para>
        </listitem>

        <listitem>
          <para><package>org.gvnix.security.roo.addon</package></para>
        </listitem>
      </itemizedlist>
    </listitem>
  </orderedlist>

  <para>Esto nos genera los elementos necesario con tres clase de
  ejemplo:</para>

  <orderedlist>
    <listitem>
      <para>Una clase <classname>Commands</classname>: Clase que declara los
      <emphasis>comandos</emphasis> que expone el add-on.</para>
    </listitem>

    <listitem>
      <para>Una interfaz <classname>Operations</classname>: Interfaz de
      ejemplo con los métodos declarados para los
      <emphasis>comandos</emphasis> registrados.</para>
    </listitem>

    <listitem>
      <para>Una clase <classname>OperationsImpl</classname>: Clase de ejemplo
      que implementa la interfaz <classname>Operations</classname> para la
      implementación de los comandos registrados.</para>
    </listitem>

    <listitem>
      <para>Una clase <classname>PropertyName</classname>: Clase de ejemplo de
      declaración/registro de propiedades de tipo enumerados disponibles para
      la línea de comando con autocompletados. Para mostrar las opciones
      inicializadas en la clase de un parámetro asociado al comando.</para>
    </listitem>
  </orderedlist>

  <para>Si vamos a trabajar con Eclipse podemos ejecutar:</para>

  <itemizedlist>
    <listitem>
      <para>Desde la consola del framework:</para>

      <programlisting>perform eclipse</programlisting>
    </listitem>

    <listitem>
      <para>Desde el shell del sistema:</para>

      <programlisting>mvn eclipse:eclipse</programlisting>
    </listitem>
  </itemizedlist>

  <section xml:id="creacion-addon_osgi">
    <title xml:lang="es">Declaración y uso de componente-servicios
    OSGi</title>

    <para>El framework funciona sobre la implementación OSGi <link
    xlink:href="http://felix.apache.org/">Apache Felix</link>. Todos los
    servicios (excepto algunas utilidades que se acceden a través de métodos
    estáticos) están declarados como componente-servicio OSGi.</para>

    <para>Un componente-servicio OSGi se declara:</para>

    <orderedlist>
      <listitem>
        <para>Definiendo un interface para el acceso a los métodos del
        servicio.</para>
      </listitem>

      <listitem>
        <para>Clases que implementan ese interface que ofrecen ese servicio
        anotadas con <classname>@Component</classname> y
        <classname>@Service</classname>.</para>
      </listitem>

      <listitem>
        <para>Las implementaciones de servicio no deben tener constructor
        declarado.</para>
      </listitem>

      <listitem>
        <para>Si las implementaciones de servicio requieren algún tipo de
        inicialización deben implementar los métodos
        <methodname>activate</methodname> y
        <methodname>deactivate</methodname> que serán llamados por OSGi en la
        activación y desactivación del servicio respectivamente. La firma de
        estos métodos es la siguiente:</para>

        <programlisting>  protected void activate(ComponentContext context) {

  }

  protected void deactivate(ComponentContext context) {

  }</programlisting>
      </listitem>
    </orderedlist>

    <para>El framework OSGi se encarga de construir las instancias de los
    servicio e inicializarlas correctamente. La implementación a usar por cada
    interface las decide el framework en base a la prioridades de cada
    servicio o su disponibilidad. Este es un ejemplo de un servicio
    OSGi:</para>

    <programlisting>// Service interface
public interface MyService {
  public String sayHello();
}</programlisting>

    <programlisting>// Service implementation
@Component
@Service
public class MyServiceImpl implements MyService{
  
  private String helloPhrase;

  protected void activate(ComponentContext context) {
     helloPhrase = "Hello Man!";
  }

  protected void deactivate(ComponentContext context) {
     helloPhrase = null;
  }

  public String sayHello(){
     return helloPhrase;
  }
}</programlisting>

    <para>Para usar un servicio OSGi:</para>

    <orderedlist>
      <listitem>
        <para>La clase debe de ser un componente OSGi, para ello debe de estar
        anotada con <classname>@Component</classname>. En el caso que la clase
        se abstracta, deberemos usar la anotación
        <classname>@AbstractComponent</classname>. La clase puede o no ser a
        su vez un servicio (<classname>@Service</classname>).</para>
      </listitem>

      <listitem>
        <para>Declararemos una propiedad privada del tipo del interface del
        servicio.</para>
      </listitem>

      <listitem>
        <para>Anotaremos dicha propiedad con
        <classname>@Reference</classname>.</para>
      </listitem>
    </orderedlist>

    <para>El framework OSGi se encargará de inyectarnos la implementación
    correspondiente en esta propiedades.</para>

    <para>Un ejemplo de uso del ejemplo de servicio anterior:</para>

    <programlisting>@Component
public class MyServiceUser{

  @Reference
  private MyService service;

  public void printSayHello(){
    System.out.println(service.sayHello());
  }
}</programlisting>

    <para>Cabe destacar una serie de comando útiles para identificar problemas
    con los componente OSGi que ofrece el framework:</para>

    <variablelist>
      <varlistentry>
        <term>osgi log</term>

        <listitem>
          <para>Muestra el log de framework OSGi. Permite ver excepciones
          producidas en la inicialización y activación de servicios y
          componentes (puede que estos mensaje se produzcan sin que se
          muestren en otro sitio).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>osgi ps</term>

        <listitem>
          <para>Muestra los bundles (conjuntos de componentes OSGi) instalados
          y su estado</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>osgi scr list</term>

        <listitem>
          <para>Muestra los componentes-servicio instalados y su
          estado.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>felix shell</term>

        <listitem>
          <para>Permite ejecutar comandos directamente al framework
          OSGi.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Para más información sobre los comandos relacionados disponibles
    usar <command>help osgi</command> y <command>felix shell help</command>
    desde la consola del framework.</para>
  </section>

  <section xml:id="creacion-addon_commands" xml:lang="es">
    <title xml:lang="es">La clase Commands</title>

    <para xml:lang="es">Clase de registro de operaciones. Esta clase no
    requiere registro, será localizada como servicio OSGi al implementar el
    interface <classname>CommandMarker</classname>. Los requisitos para que
    esta clase sea usada en el framework son los siguientes:</para>

    <orderedlist>
      <listitem>
        <para>implementar el interface
        <classname>org.springframework.roo.shell.CommandMarker</classname>.</para>
      </listitem>

      <listitem>
        <para>La clase debe ser un <link
        linkend="creacion-addon_osgi">componente-servicio OSGi</link>.</para>
      </listitem>

      <listitem>
        <para>Contiene dos tipos de métodos:</para>

        <orderedlist>
          <listitem>
            <para>Indicadores de <emphasis><link
            linkend="creacion-addon_commands_accesibilidad">accesibilidad</link></emphasis>:
            Indician si un comando es accesible para el usuario en el contexto
            actual.</para>
          </listitem>

          <listitem>
            <para><link
            linkend="creacion-addon_commands_command">Comandos</link>: Punto
            de entrada y registro de un comando.</para>
          </listitem>
        </orderedlist>
      </listitem>

      <listitem>
        <para>Tendrá poca o ninguna implementación. La implementación de las
        acciones se realizará en las clases <link
        linkend="creacion-addon_operationsimpl">OperationsImpl</link>.</para>
      </listitem>
    </orderedlist>

    <para>Estas clases no requieren ser registradas ya que se localizan
    gracias al framework OSGi.</para>

    <section xml:id="creacion-addon_commands_accesibilidad" xml:lang="es">
      <title xml:lang="es">Métodos de accesibilidad</title>

      <para>Estos métodos deben de hacer las comprobaciones necesarias para
      indicar si un comando o comandos deben estar accesible para el usuario.
      Su características principales son:</para>

      <itemizedlist>
        <listitem>
          <para>El método está anotado con la anotación
          <classname>@CliAvailabilityIndicator</classname>, con los parámetros
          la lista de comandos a los que afecta.</para>
        </listitem>

        <listitem>
          <para>Devuelven <literal>boolean</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>Estos son ejemplos de estos métodos:</para>

      <programlisting>    @CliAvailabilityIndicator("myaddon setup")
    public boolean isSetupAvailable(){
        return true; 
    }

    @CliAvailabilityIndicator({"myaddon add", "myaddon remove", "myaddon update"})
    public boolean isActionsAvailable(){
        return true;
    }</programlisting>
    </section>

    <section xml:id="creacion-addon_commands_command" xml:lang="es">
      <title xml:lang="es">Métodos de comando</title>

      <para xml:lang="es">Definición y punto de entrada de los comando que
      registra nuestro plugin. Sus características son:</para>

      <itemizedlist>
        <listitem>
          <para>El método debe estar anotado con
          <classname>@CliCommand</classname>. Los parámetros de esta anotación
          son:</para>

          <variablelist>
            <varlistentry>
              <term>value</term>

              <listitem>
                <para>Cadena del comando</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>help</term>

              <listitem>
                <para>Cadena de ayuda para este comando. Usado por el comando
                <command>help</command> y el autocompletado del
                framework.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>

        <listitem>
          <para>Cada parámetro debe estar anotado con
          <classname>@CliOption</classname>. Los parámetros de esta anotación
          son:</para>

          <variablelist>
            <varlistentry>
              <term>key</term>

              <listitem>
                <para>Nombre del parámetro para el shell. El usuario podrá
                usar el parámetro usando el nombre que indiquemos aquí
                precedido de dos guiones (<literal>--</literal>). Es posible
                añadir mas de un key. Si se añade una cadena vacía se asumirá
                que es el parámetro por defecto (por ejemplo es equivalente el
                comando <command>field string campoCadena</command> que
                <command>entity --fieldName campoCadena</command>).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>mandatory</term>

              <listitem>
                <para>Indica si el parámetro es requerido o no.
                Booleano.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>specifiedDefaultValue</term>

              <listitem>
                <para>Valor que recibe parámetro a usar si es añadido el
                parámetro en el comando por el usuario sin especificar ningún
                valor. Muy útil para los parámetro tipo booleanos.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>unspecifiedDefaultValue</term>

              <listitem>
                <para>Valor que recibe este parámetro si es omitido en la
                línea de comando. Admite el valor <literal>"*"</literal> que
                usara como valor el <emphasis>foco</emphasis> actual del shell
                (un ejemplo es la omisión del parámetro
                <parameter>--class</parameter> en el comando
                <command>field</command> justo después de usar el comando
                <command>entity</command>).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>help</term>

              <listitem>
                <para>Texto de ayuda, usado en el comando
                <command>help</command> y en el autocompletado.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>optionContext</term>

              <listitem>
                <para>Opciones de contexto para el parámetro. Esta cadena es
                útil para configurar los parámetro de un tipo asociado a un
                <link
                linkend="creacion-addon_converters">Converter</link>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>

        <listitem>
          <para>Su valor de retorno debe ser void o String, dependiendo si es
          un comando que realiza alguna opción o es un comando que devuelve
          información a la consola (como el <command>help</command>,
          <command>hint</command> o el <command>properties
          list</command>).</para>
        </listitem>
      </itemizedlist>

      <para xml:lang="es">Estos son ejemplos de estos métodos:</para>

      <programlisting>  @CliCommand(value="welcome write hello", help="Writes hello.txt in the project root directory")
  public void writeHello() {
     operations.writeTextFile("hello");
  }
  
  @CliCommand(value="welcome property", help="Obtains a pre-defined system property")
  public String property(
          @CliOption(key="name", 
              mandatory=false, 
              specifiedDefaultValue="USERNAME", 
              unspecifiedDefaultValue="USERNAME", 
              help="The property name you'd like to display") PropertyName propertyName) {
     return operations.getProperty(propertyName);
  }</programlisting>
    </section>
  </section>

  <section xml:id="creacion-addon_converters" xml:lang="es">
    <title xml:lang="es">Converters del Shell</title>

    <para xml:lang="es">Son clases del Shell del framework que permiten
    transformar las cadenas que introduce el usuario en la línea de comandos
    en las clases Java que usarán la clase Commands. Además, estas clases son
    las que permiten el autocompletado de los valores de los parámetros en el
    Shell.</para>

    <para xml:lang="es">Sus características principales son:</para>

    <orderedlist>
      <listitem>
        <para>Deben implementar el interface
        <classname>org.springframework.roo.shell.Converter</classname>.</para>
      </listitem>

      <listitem>
        <para>Deben ser <link
        linkend="creacion-addon_osgi">componente-servicio OSGi</link>.</para>
      </listitem>
    </orderedlist>

    <para>Existen algunos ya registrados en el sistema que pueden ser
    útiles:</para>

    <itemizedlist>
      <listitem>
        <para><classname>StaticFieldConverter</classname>: Nos permite
        registrar enumerados Java.</para>
      </listitem>
    </itemizedlist>

    <para>Estas clases pueden ser muy útiles si nuestro add-on trabaja con
    tipos (por ejemplo un datos de un elementos de menú). En el add-on se ha
    definido una clase para el tipo en cuestión y crea un converter que
    permita la conversión de lo que introduzca el usuario en el Shell al tipo.
    Es recomendable que estos tipos se creen como <emphasis>tipos
    inmutables</emphasis> (al objeto de tipos se inicializa en el constructor
    y no permite modificar sus datos).</para>

    <para>TBC [Añadir la descripción de la clase]</para>
  </section>

  <section xml:id="creacion-addon_operations" xml:lang="es">
    <title xml:lang="es">La interface Operations</title>

    <para xml:lang="es">Es la Interfaz dónde se definen los métodos necesarios
    para el funcionamiento del Add-on. Para ser invocados desde la clase
    <classname>Commands</classname> o desde otro Add-on que pueda
    utilizarlos.</para>
  </section>

  <section xml:id="creacion-addon_operationsimpl" xml:lang="es">
    <title xml:lang="es">La clase OperationsImpl</title>

    <para xml:lang="es">Esta clase implementa la interfaz definida
    <classname>Operations</classname>. Contendrá la implementación de las
    operaciones disponibles en el add-on.</para>

    <para xml:lang="es">Sus requisitos son:</para>

    <itemizedlist>
      <listitem>
        <para>Debe ser un <link
        linkend="creacion-addon_osgi">componente-servicio OSGi</link>.</para>
      </listitem>

      <listitem>
        <para>Implementar el interface <classname>Operations</classname> que
        usará la clase <classname>Commands</classname>.</para>
      </listitem>

      <listitem>
        <para>No tener método constructor.</para>
      </listitem>
    </itemizedlist>

    <para xml:lang="es">Si la clase necesita inicialización o registrar otros
    componentes debería utilizar los métodos <classname>activate</classname> y
    <classname>deactivate</classname> del los componentes-servicios
    OSGi.</para>

    <para>Para estas clases podemos dar la siguientes recomendaciones:</para>

    <itemizedlist>
      <listitem>
        <para>Intentar que los estados usado para tomar las decisiones de si
        está activado o no algún comando sean lo más simples posible o que
        estén <emphasis>cacheados</emphasis> (aunque suponga implementar algún
        listener para identificar cambios de estado).</para>

        <para>Los métodos de habilitación de comandos son llamados
        <emphasis>muy frecuentemente</emphasis> (por ejemplo con el uso de la
        tecla <literal>TAB</literal> del autocompletado del Shell). Una mala
        implementación de esto puede repercutir seriamente en la agilidad de
        uso del framework.</para>
      </listitem>

      <listitem>
        <para>Intentar evitar las referencias cíclicas entre
        componentes-servicios OSGi.</para>

        <para>Podemos encontrarnos que intentamos usar un servicio que no está
        cargado porque, a su vez este servicio requiere de nuestro
        componente.</para>

        <para>Si aun así no encontramos con este problema, intentar usar
        mecanismos de <emphasis>ejecución retardada</emphasis>. Como por
        ejemplo, acumular en una lista las operaciones a realizar hasta que
        detectemos que todos los servicios necesarios están disponibles (un
        <classname>ProcessListener</classname> puede ayudar).</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="creacion-addon_propertyname" xml:lang="es">
    <title xml:lang="es">La clase PropertyName</title>

    <para xml:lang="es">Esta clase es un ejemplo de clase que se puede
    registrar en el <classname>StaticFieldConverter</classname> comentado en
    la sección de <link
    linkend="creacion-addon_converters">Converter</link>.</para>
  </section>

  <section xml:id="creacion-addon_test" xml:lang="es">
    <title xml:lang="es">Test unitarios</title>

    <para xml:lang="es">Para mantener y garantizar la calidad en los add-on
    generados es fundamental que estos tengan implementados una batería de
    pruebas unitarias para las operaciones principales de los add-on.</para>

    <section xml:id="creacion-addon_test_tdd" xml:lang="es">
      <title xml:lang="es">Desarrollo dirigido por Test (RDA)</title>

      <para xml:lang="es">Desarrollo dirigido por Test o Test-driven
      development (TDD) es una práctica de programación que se basa en la
      repetición de un ciclo de desarrollo muy corto. En primer lugar se
      escribe una prueba (test) y se verifica que la prueba falle, luego se
      implementa el código que haga que la prueba pase satisfactoriamente y
      seguidamente se refactoriza el código escrito. La idea es que los
      requerimientos sean traducidos a pruebas, de este modo, cuando las
      pruebas pasen se garantizará que los requerimientos se hayan
      implementado correctamente.</para>
    </section>

    <section xml:id="creacion-addon_test_test" xml:lang="es">
      <title xml:lang="es">Test Unitarios</title>

      <para xml:lang="es">Los Test unitarios son una forma de probar el
      correcto funcionamiento de un módulo de código, en este caso las
      operaciones de un add-on. Esto sirve para asegurar que cada una de las
      operaciones funciona correctamente por separado. Se contemplan los casos
      posibles de error para el desarrollo dirigido por test y así asegurar su
      correcto funcionamiento e implementación del código necesario.</para>
    </section>

    <section xml:id="creacion-addon_test_mock" xml:lang="es">
      <title xml:lang="es">Objetos Mock</title>

      <para xml:lang="es">Los tests unitarios se centran en módulos de código
      concretos. A veces un módulo necesita o utiliza un objeto externo para
      realizar una operación, por ejemplo una operación de un add-on necesita
      utilizar un servicio que pertenece a otro add-on, para poder desarrollar
      un test con todos los resultados posibles relacionados con el servicio
      que utiliza, debemos simular el comportamiento del servicio mediante un
      Mock para centrarnos en los tests del módulo concreto.</para>

      <para xml:lang="es">Un Mock es un objeto creado para reemplazar el
      comportamiento del original, simular su comportamiento dentro del test
      que se está desarrollando. El Mock se instancia como parámetro de la
      clase sobre la que vamos a crear las pruebas e implementamos el
      comportamiento que va a tener dentro del test en cuestión. Nos permite
      simular la llamada a este objeto definiendo los parámetros de entrada y
      de salida.</para>

      <para xml:lang="es">Un Mock puede simular el comportamiento de cualquier
      clase, no es imprescindible que sea un servicio.</para>

      <para xml:lang="es">Para el desarrollo de los tests mediante Mocks
      utilizaremos la librería EasyMock:</para>

      <para xml:lang="es"><link
      xlink:href="http://www.easymock.org/">http://www.easymock.org/</link></para>

      <para xml:lang="es">Ejemplo:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Crear el servicio que utiliza como un Mock e
          instanciarlo a la clase de test para sustituir el original:</para>

          <programlisting>// Mock objects to emulate Roo OSGi Services
private FileManager fileManager;
...
fileManager = createMock(FileManager.class);
ReflectionTestUtils.setField(webExceptionHandlerOperationsImpl, "fileManager", fileManager);</programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Simular la llamada al método (utilizando el
          método expect) con los parámetros que se utilizan en la operación
          para devolver con el método andReturn el resultado que
          esperamos:</para>

          <programlisting>expect(fileManager.exists("webmvc-config.xml")).andReturn(true);</programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Antes de ejecutar la llamada al método de la
          clase sobre la que se desarrollan los tests, se ejecuta el método
          replay sobre los Mocks de los que se ha definido su
          comportamiento:</para>

          <programlisting>replay(fileManager);
webExceptionHandlerOperationsImpl.getHandledExceptionList();</programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Después de la ejecución del test se han de
          reiniciar los valores de los Mocks utilizados durante la llamada al
          método sobre el que se han ejecutado los tests con el comando
          reset:</para>

          <programlisting>reset(fileManager);</programlisting>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="creacion-addon_test_ejemplo" xml:lang="es">
      <title xml:lang="es">Ejemplo</title>

      <para xml:lang="es">Ejemplo simple de test unitario usando Mocks para
      simular los servicios osgi para una operación del add-on
      <emphasis>addon-web-exception-handler</emphasis>.</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Añadir dependencias correspondientes al proyecto
          add-on.</para>

          <para xml:lang="es">Para el desarrollo de tests en un add-on se
          necesita importar las librerías de test en el pom.xml del
          proyecto:</para>

          <programlisting>&lt;!-- Unit Test dependencies --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.easymock&lt;/groupId&gt;
  &lt;artifactId&gt;easymock&lt;/artifactId&gt;
  &lt;version&gt;3.0&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;${spring.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
  &lt;version&gt;${spring.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;commons-logging&lt;/groupId&gt;
  &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
  &lt;version&gt;1.1.1&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Crear la clase de Test</para>

          <para xml:lang="es">Este primer test está dirigido a la clase
          Operations del Addon WebExceptionHandlerOperationsImpl.</para>

          <orderedlist>
            <listitem>
              <para xml:lang="es">Crear una nueva clase utilizando el nombre
              de la clase que se quiere hacer el test añadiendo el sufijo
              Test: WebExceptionHandlerOperationsImplTest.</para>
            </listitem>

            <listitem>
              <para xml:lang="es">Declarar como atributo la clase sobre la que
              se quieren ejecutar los tests y los servicios que utiliza la
              clase operations del Addon:</para>

              <programlisting>//Class under test
private WebExceptionHandlerOperationsImpl exceptionHandlerOperationsImpl;

// Mock objects to emulate Roo OSGi Services
private FileManager fileManager;
private MetadataService metadataService;
private PathResolver pathResolver;
private PropFileOperations propFileOperations;

// Mock to emulate file management.
private MutableFile webXmlMutableFile;

// Files to use placed in src/test/resorces
static final String EXC_WEB_XML = "exceptions-webmvc-config.xml";
static final String NO_EXC_WEB_XML = "no-exceptions-webmvc-config.xml";

// Project web config file path
static final String WEB_XML_PATH = "WEB-INF/spring/webmvc-config.xml";</programlisting>
            </listitem>

            <listitem>
              <para xml:lang="es">Utilizando las anotaciones de JUnit se ha de
              instanciar la clase de test y los servicios que utiliza para
              simular su comportamiento instanciándolos como Mocks:</para>

              <programlisting>/**
 * Setup operations instance and Mock objects
 *
 * @throws java.lang.Exception
 */
@Before
public void setUp() throws Exception {

  // Class under test
  webExceptionHandlerOperationsImpl = new WebExceptionHandlerOperationsImpl();

  // Setup Mock service objects
  fileManager = createMock(FileManager.class);
  metadataService = createMock(MetadataService.class);
  pathResolver = createMock(PathResolver.class);
  propFileOperations = createMock(PropFileOperations.class);

  // Mock Objects
  webXmlMutableFile = createMock(MutableFile.class);

  // Inject mock objects in instance. This emulate OSGi environment
  ReflectionTestUtils.setField(webExceptionHandlerOperationsImpl, "fileManager", fileManager);
  ReflectionTestUtils.setField(webExceptionHandlerOperationsImpl, "metadataService", metadataService);
  ReflectionTestUtils.setField(webExceptionHandlerOperationsImpl, "pathResolver", pathResolver);
  ReflectionTestUtils.setField(webExceptionHandlerOperationsImpl, "propFileOperations", propFileOperations);
}</programlisting>

              <para xml:lang="es">El método <emphasis>setUp()</emphasis> se
              ejecuta antes de cada test de esta clase debido a la anotación
              <emphasis>@Before</emphasis> para instanciar los elementos
              necesarios en cada método de la clase operations. Ahora se han
              de crear los métodos de test por cada uno de los métodos
              implementados en la clase de operaciones del add-on. Puede que
              para algunos métodos no sea necesario el test debido a la
              simplicidad que representan, pero es recomendable crearlos
              también.</para>
            </listitem>

            <listitem>
              <para xml:lang="es">Crear test para el método
              <emphasis>getHandledExceptionList():</emphasis></para>

              <programlisting>/**
 * Checks method
 * {@link WebExceptionHandlerOperationsImpl#getHandledExceptionList()}
 * 
 * @throws Exception
 */
@Test
public void testGetHandledExceptionList() throws Exception {

  String result;
  String expected;

  /*
   * Test 1 - Encuentra excepciones instanciadas en el archivo de
   * configuración EXC_WEB_XML
   */
  expect(pathResolver.getIdentifier(Path.SRC_MAIN_WEBAPP, WEB_XML_PATH)).andReturn(EXC_WEB_XML);

  expect(fileManager.exists(EXC_WEB_XML)).andReturn(true);

  expect(fileManager.updateFile(EXC_WEB_XML)).andReturn(webXmlMutableFile);

  expect(webXmlMutableFile.getInputStream()).andReturn(getClass().getResourceAsStream(EXC_WEB_XML));

  replay(pathResolver, fileManager, webXmlMutableFile);

  result = webExceptionHandlerOperationsImpl.getHandledExceptionList();

  assertTrue("There aren't exceptions defined in " + EXC_WEB_XML + " file", result != null);

  reset(pathResolver, fileManager, webXmlMutableFile);

  /*
   * Test 2 - No encuentra excepciones instanciadas en el archivo de
   * configuración NO_EXC_WEB_XML
   */
  expect(pathResolver.getIdentifier(Path.SRC_MAIN_WEBAPP, WEB_XML_PATH)).andReturn(NO_EXC_WEB_XML);

  expect(fileManager.exists(NO_EXC_WEB_XML)).andReturn(true);

  expect(fileManager.updateFile(NO_EXC_WEB_XML)).andReturn(webXmlMutableFile);

  expect(webXmlMutableFile.getInputStream()).andReturn(getClass().getResourceAsStream(NO_EXC_WEB_XML));

  replay(pathResolver, fileManager, webXmlMutableFile);

  result = webExceptionHandlerOperationsImpl.getHandledExceptionList();

  expected = "Handled Exceptions:\n";

  assertEquals("There are exceptions defined in " + NO_EXC_WEB_XML
    + " file", expected, result);

  reset(pathResolver, fileManager, webXmlMutableFile);

}</programlisting>

              <para xml:lang="es">Se añade la anotación
              <emphasis>@Test</emphasis> de <emphasis>JUnit</emphasis> para
              que el método sea reconocido y se ejecute al lanzar el comando
              test de maven.</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para xml:lang="es">Archivos <emphasis>xml</emphasis> para obtener
          los resultados del test.</para>

          <para xml:lang="es">Este test se basa en la comprobación de datos
          que se obtienen de un archivo xml de configuración de un proyecto.
          Los casos de uso del test están relacionados con el tratamiento de
          archivos por eso necesitamos crear los archivos para obtener las
          distintas soluciones.</para>

          <para xml:lang="es">Crear los archivos xml que se utilizarán para la
          ejecución del test <emphasis>exceptions-webmvc-config.xml</emphasis>
          y <emphasis>no-exceptions-webmvc-config.xml</emphasis> en el mismo
          paquete java que se ha creado el test dentro de la carpeta
          <emphasis>src/test/resources</emphasis>.</para>

          <para xml:lang="es">El primero de los archivos <emphasis>contiene
          las excepciones instanciadas</emphasis> para que el test funcione
          correctamente según se ha implementado el <emphasis>Test
          1:</emphasis></para>

          <programlisting>&lt;!-- This bean resolves specific types of exceptions to corresponding logical - view names for error views. 
     The default behaviour of DispatcherServlet - is to propagate all exceptions to the servlet container: 
     this will happen - here with all other types of exceptions. --&gt;
&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver" p:defaultErrorView="uncaughtException"&gt;
 &lt;property name="exceptionMappings"&gt;
  &lt;props&gt;
   &lt;prop key=".DataAccessException"&gt;dataAccessFailure&lt;/prop&gt;
   &lt;prop key=".NoSuchRequestHandlingMethodException"&gt;resourceNotFound&lt;/prop&gt;
   &lt;prop key=".TypeMismatchException"&gt;resourceNotFound&lt;/prop&gt;
   &lt;prop key=".MissingServletRequestParameterException"&gt;resourceNotFound&lt;/prop&gt;
  &lt;/props&gt;
 &lt;/property&gt;
&lt;/bean&gt;</programlisting>

          <para xml:lang="es">Mientras que el segundo <emphasis>no contiene
          excepciones instanciadas</emphasis>, se utiliza en el <emphasis>Test
          2</emphasis> para comprobar que no existen excepciones en el archivo
          de configuración correspondiente:</para>

          <programlisting>&lt;!-- This bean resolves specific types of exceptions to corresponding logical - view names for error views. 
     The default behaviour of DispatcherServlet - is to propagate all exceptions to the servlet container: 
     this will happen - here with all other types of exceptions. --&gt;
&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver" p:defaultErrorView="uncaughtException"&gt;
 &lt;property name="exceptionMappings"&gt;
  &lt;props&gt;
  &lt;/props&gt;
 &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Recomendaciones sobre el desarrollo de los add-on</title>

    <para>En este apartado se añaden una serie de recomendaciones y las
    conveciones sobre la creación/implementación de los add-ons.</para>

    <para>Una lectura interesante en este sentido es la presentación de Ben
    Alex sobre el desarrollo de roo disponible en <link
    xlink:href="http://www.slideshare.net/benalexau/spring-roo-100-technical-deep-dive">Spring
    Roo 1.0.0 Technical Deep Dive</link>.</para>

    <section>
      <title>Evitar lanzar un error si podemos dar la solución</title>

      <para>Una de las premisas que parece reinar el proyecto Roo es que si el
      add-on, ante la falta de algún paso, si es conocedor de como solucionar
      la falta, intentar solucionarlo el mismo en vez de <emphasis>protestar y
      alguien los solucionara</emphasis>.</para>
    </section>

    <section>
      <title>Si ya existe alguien que sabe resolverlo, que se encargue de
      ello</title>

      <para>Si nuestro add-on depende de que otro se ejecute, deberíamos
      intentar, en la medida de lo posible, que sea él el que resuelva el
      problema. Un ejemplo puede ser que si nuestro add-on registra un
      <emphasis>Proveedor de autenticación</emphasis> y no se ha instalado las
      dependencias de las librería adecuadas, delegaremos en el add-on
      existente para que realice la tarea.</para>
    </section>

    <section>
      <title>Actualización de Add-ons</title>

      <para>Nuestro add-on debería identificar productos generados por otras
      versiones de si mismo y <emphasis>actualizarlos</emphasis> de forma
      coherente.</para>
    </section>

    <section>
      <title>Anotaciones mejor que ficheros de configuración</title>

      <para>Para simplificar el mantenimiento y reducir el número de
      artefactos a gestionar en la aplicación, debemos de tender a usar
      anotaciones, siempre que sea adecuado y con sentido común, en vez de
      registro en el los ficheros de contexto Spring.</para>
    </section>

    <section>
      <title>Evitar en lo posible ficheros properties de configuración</title>

      <para>Cuando usemos variables, es recomendable que los valores sean
      actualizados en los <emphasis>ficheros de contexto de Spring</emphasis>,
      siempre se sea posible, en vez de repartirlos por fichero
      <filename>.properties</filename>.</para>

      <para>Si estos valores son dependientes del entorno, como en el caso del
      uso de profiles de maven, es preferible tratar los fichero de Spring en
      la compilación que en un <filename>.properties</filename>.</para>
    </section>

    <section>
      <title>Agilidad en métodos de disponibilidad de comandos</title>

      <para>Ya que los método de <emphasis>disponibilidad de un
      comando</emphasis> pueden ser llamados desde la línea de comandos y de
      manera muy frecuente, tendríamos que cuidar de que fuesen <emphasis>lo
      más sencillos y optimizados posible </emphasis>.</para>

      <para>Por ejemplo, intentar ver si comprobando dependencias del proyecto
      y/o la existencia de algún/os ficheros tenemos suficiente o usar
      variables de estado <emphasis>cacheadas</emphasis>, coordinado con algún
      listener que las limpie cuando convenga.</para>
    </section>

    <section>
      <title>add-ons genéricos y específicos CIT</title>

      <para>Intentaremos implementar add-ons de consola Roo genéricos para que
      puedan ser utilizados en múltiples ámbitos y luego estos add-ons podrían
      ser personalizados para la CIT mediante scripts de consola Roo.</para>

      <para>Adicionalmente, puede ser interesante, en algunos casos, que
      algunos de nuestros add-ons necesiten ejecutar como paso previo otro
      addon antes de realizar sus tareas. Por ejemplo, la instalación del
      sistema de seguridad de la CIT requiere que antes se haya ejecutado la
      instalación del sistema de seguridad de Spring, por lo que lo más
      recomendable es que nuestro addon de seguridad CIT invoque como paso
      previo al addon de seguridad Spring, si no hubiese sido ejecutado
      todavía. La finalidad que se busca es que no obligar a invocar a un
      comando manualmente antes de invocar a otro comando.</para>
    </section>
  </section>
</chapter>
